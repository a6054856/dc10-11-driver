#### UART总线通讯协议

#### 一、串口通讯协议层

串口通讯的数据包由发送设备通过自身的TXD接口传输到接收设备的RXD接口。在串口通讯的协议层中，规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据，其组成见图 206。

![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20180717151652469.png)

图 206 串口数据包的基本组成

##### 1.  波特率

本章中主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号(如前面讲解的DB9接口中是没有时钟信号的)，所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码，图 206中用虚线分开的每一格就是代表一个码元。常见的波特率为4800、9600、115200等。

##### 2.  通讯的起始和停止信号

串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑0的数据位表示，而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，只要双方约定一致即可。

##### 3.  有效数据

在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为5、6、7或8位长。

##### 4.  数据校验

在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、0校验(space)、1校验(mark)以及无校验(noparity)，它们介绍如下：

​		奇校验要求有效数据和校验位中"1"的个数为奇数，比如一个8位长的有效数据为：01101001，此时总共有4个"1"，为达到奇校验效果，校验位为"1"，最后传输的数据将是8位的有效数据加上1位的校验位总共9位。

​		偶校验与奇校验要求刚好相反，要求帧数据和校验位中"1"的个数为偶数，比如数据帧：11001010，此时数据帧"1"的个数为4个，所以偶校验位为"0"。

​		0校验是不管有效数据中的内容是什么，校验位总为"0"，1校验是校验位总为"1"。

​		在无校验的情况下，数据包中不包含校验位。



*******************************************************************************************************************************************************************************************************************************************************************************************************

# I2C总线通讯协议

## 1. I2C总线简介

I2C是Inter-Integrated Circuit的简称，读作：I-squared-C。由飞利浦公司于1980年代提出，为了让主板、嵌入式系统或手机用以连接低速周边外部设备而发展。

主要用途：

SOC和周边外设间的通信（如：EEPROM，电容触摸芯片，各种Sensor等）。

### 1.1 物理接口

I2C总线只使用两条双向漏极开路的信号线（串行数据线：SDA，及串行时钟线：SCL），并利用**电阻上拉**。I2C总线仅仅使用SCL、SDA两根信号线，就实现了设备间的数据交互，极大地简化了对硬件资源和PCB板布线空间的占用。I2C总线广泛应用在EEPROM、实时时钟、LCD、及其他芯片的接口。I2C允许相当大的工作电压范围，典型的电压基准为：+3.3V或+5V。

**SCL（Serial Clock）**：串行时钟线，传输CLK信号，一般是主设备向从设备提供
**SDA（Serial Data）**：串行数据线，传输通信数据

I2C总线接口内部结构如下图所示：

![I2C总线接口内部结构](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180308121222682-845094129.png)

I2C使用一个7bit的设备地址，一组总线最多和112个节点通信。最大通信数量受限于地址空间及400pF的总线电容。

常见的I2C总线以传输速率的不同分为不同的模式：标准模式（100Kbit/s）、低速模式（10Kbit/s）、快速模式（400Kbit/s）、高速模式（3.4Mbit/s），时钟频率可以被下降到零，即暂停通信。

该总线是一种多主控总线，即可以在总线上放置多个主设备节点，在停止位（P）发出后，即通讯结束后，主设备节点可以成为从设备节点。

**主设备节点**：产生时钟并发起通信的设备节点
**从设备节点**：接收时钟并响应主设备节点寻址的设备节点

```
 1）I2C通信双方地位不对等，通信由主设备发起，并主导传输过程，从设备按I2C协议接收主设备发送的数据，并及时给出响应。
 2）主设备、从设备由通信双方决定（I2C协议本身无规定），既能当主设备，也能当从设备（需要软件进行配置）。
 3）主设备负责调度总线，决定某一时刻和哪个从设备通信。同一时刻，I2C总线上只能有一对主设备、从设备通信。
 4）每个I2C从设备在I2C总线通讯中有一个I2C从设备地址，该地址唯一，是从设备的固有属性，通信中主设备通过从设备地址来找到从设备。
```

I2C总线多主设备结构如下图所示：

![I2C总线多主设备结构](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180308121329120-1020495941.png)

### 1.2 通讯特征

串行、同步、非差分、低速率

1）串行通信，所有的数据以位为单位在SDA线上串行传输
2）同步通信，即双方工作在同一个时钟下，一般是通信的A方通过一根CLK信号线，将A设备的时钟传输到B设备，B设备在A设备传输的时钟下工作。同步通信的特征是：通信线中有CLK。
3）非差分，I2C通信速率不高，且通信距离近，使用电平信号通信。
4）低速率，I2C一般是同一个板子上的两个IC芯片间通信，数据量不大，速率低。速率：几百KHz，速率可能不同，不能超过IC的最高速率。

### 1.3 I2C总线状态

I2C总线上有两种状态：

空闲态：没有设备发生通信。
忙态：其中一个从设备和主设备通信，I2C总线被占用，其他从设备处于等待状态。

## 2. I2C总线通信协议

时序：在通信中时序是通信线上按时间顺序发生的电平变化，及这些电平变化对通信的意义。

每个通信周期都由一个起始位开始通信，由一个结束位结束通信，中间部分是传递的数据。

每个通信周期，主设备会先发8位的从设备地址（从设备地址由高7位的实际从设备地址和低1位的读/写标志位组成），主设备以广播的形式发送从设备地址，I2C总线上的所有从设备收到地址后，判断从设备地址是否匹配，不匹配的从设备继续等待，匹配的设备发出一个应答信号。

同一时刻，主设备、从设备只能有一个设备发送数据。

### 2.1 起始位和结束位

I2C总线通讯由起始位开始通讯，由结束位停止通讯，并释放I2C总线。起始位和结束位都由主设备发出。
**起始位（S）**：在SCL为高电平时，SDA由高电平变为低电平
**结束位（P）**：在SCL为高电平时，SDA由低电平变为高电平

如下图所示：

![I2C的起始位与停止位](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180308120016624-200706126.jpg)

### 2.2 数据格式与应答

I2C数据以字节（即8bits）为单位传输，每个字节传输完后都会有一个ACK应答信号。应答信号的时钟是由主设备产生的。

**应答（ACK）**：拉低SDA线，并在SCL为高电平期间保持SDA线为低电平
**非应答（NOACK）**：不要拉低SDA线（此时SDA线为高电平），并在SCL为高电平期间保持SDA线为高电平

在传输期间，如果从设备来不及处理主设备发送的数据，从设备会保持SCL线为低电平，强迫主设备等待从设备释放SCL线，直到从设备处理完后，释放SCL线，接着进行数据传输。

如下图所示：

![I2C的数据格式与应答信号](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180307180052711-1310611393.png)

### 2.3 数据传输通讯

#### 1）写数据

开始数据传输后，先发送一个起始位（S），主设备发送一个地址数据（由7bit的从设备地址，和最低位的写标志位组成的8bit字节数据，该读写标志位决定数据的传输方向），然后，主设备释放SDA线，并等待从设备的应答信号（ACK）。每一个字节数据的传输都要跟一个应答信号位。数据传输以停止位（P）结束，并且释放I2C总线。

#### 2）读数据

开始通讯时，主设备先发送一个起始信号（S），主设备发送一个地址数据（由7bit的从设备地址，和最低位的写标志位组成的8bit字节数据），然后，主设备释放SDA线，并等待从设备的应答信号（ACK），从设备应答主设备后，主设备再发送要读取的寄存器地址，从设备应答主设备（ACK），主设备再次发送起始信号（Sr），主设备发送设备地址（包含读标志），从设备应答主设备，并将该寄存器的值发送给主设备；

**读取单字节数据**：
主设备要读取的数据，如果是只有一个字节的数值，就要结束应答，主设备要先发送一个非应答信号（NOACK），再发送结束信号（P）；
**读取多字节数据**：
主设备要读取的数据，如果是大于一个字节的多个数据，就发送ACK应答信号（ACK），而不是非应答信号（NOACK），然后主设备再次接收从设备发送的数据，依次类推，直到主设备读取的数值是最后一个字节数据后，需要主设备给从设备发送非应答信号（NOACK），再发送结束信号（P），结束I2C通讯，并释放I2C总线。

![I2C的数据传输](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180307180253337-1391219324.png)

注意：所有的数据传输过程中，SDA线的电平变化必须在SCL为低电平时进行，SDA线的电平在SCL线为高电平时要保持稳定不变。如下图所示：

![I2C数据位变化与时钟线关系](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/613630-20180308121446400-968408232.jpg)





*******************************************************************************************************************************************************************************************************************************************************************************************************

### SPI总线通讯协议

#### 1、什么是SPI？

SPI是串行外设接口(Seria Peripheral Interface)的缩写。是 Motorola 公司推出的一
种同步串行接口技术，是一种高速的，全双工，同步的通信总线。

#### 2、SPI优点

支持全双工通信
通信简单
数据传输速率块

#### 3、缺点

没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据
可靠性上有一定的缺陷。

#### 4、特点

1）：高速、同步、全双工、非差分、总线式
2）：主从机通信模式

#### 5、协议通信时序详解

1）：SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多
个从设备，需要至少4根线，事实上3根也可以(单向传输时)。也是所有基于SPI的设备共
有的，它们是SDI(数据输入)、SDO(数据输出)、SCLK(时钟)、CS(片选)。
(1)SDO/MOSI – 主设备数据输出，从设备数据输入;
(2)SDI/MISO – 主设备数据输入，从设备数据输出;
(3)SCLK – 时钟信号，由主设备产生;
(4)CS/SS – 从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设
备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需
要将从设备对应的片选引脚电平拉低或者是拉高。

![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/944893-20161027161441046-108731561.gif)

2）：需要说明的是，我们SPI通信有4种不同的模式，不同的从设备可能在出厂是就是配
置为某种模式，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们
可以对我们的主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来
控制我们主设备的通信模式，具体如下：
Mode0：CPOL=0，CPHA=0
Mode1：CPOL=0，CPHA=1
Mode2：CPOL=1，CPHA=0
Mode3：CPOL=1，CPHA=1

时钟极性CPOL是用来配置SCLK的电平出于哪种状态时是空闲态或者有效态，时钟相位CPHA
是用来配置数据采样是在第几个边沿：
CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时
CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时
CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿
CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿

例如：
CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是
SCLK由低电平到高电平的跳变，所以数据采样是在上升沿，数据发送是在下降沿。

CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是
SCLK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。

CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是
SCLK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。

CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是
SCLK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。

![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/944893-20161027161424453-974917858.gif)   

需要注意的是：我们的主设备能够控制时钟，因为我们的SPI通信并不像UART或者IIC通信
那样有专门的通信周期，有专门的通信起始信号，有专门的通信结束信号；所以我们的
SPI协议能够通过控制时钟信号线，当没有数据交流的时候我们的时钟线要么是
保持高电平要么是保持低电平。

#### 6、内部工作机制

![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/944893-20161027161417046-1214549547.jpg)

我们知道, 在每个时钟周期内, Master 与 Slave 之间交换的数据其实都是 SPI 内部[移位寄存器](https://www.eefocus.com/tag/移位寄存器)从 SSPBUF 里面拷贝的 . 我们可以通过往 SSPBUF 对应的寄存器 (Tx-Data / Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF。

 

例如, 在发送数据之前, 我们应该先往 Master 的 Tx-Data 寄存器写入将要发送出去的数据, 这些数据会被 Master-SSPSR 移位寄存器根据 Bus-Width 自动移入 Master-SSPBUF 里, 然后这些数据又会被 Master-SSPSR 根据 Channel-Width 从 Master-SSPBUF 中移出, 通过 Master-SDO 管脚传给 Slave-SDI 管脚, Slave-SSPSR 则把从 Slave-SDI 接收到的数据移入 Slave-SSPBUF 里 . 与此同时, Slave-SSPBUF 里面的数据根据每次接收数据的大小(Channel-Width), 通过 Slave-SDO 发往 Master-SDI, Master-SSPSR 再把从 Master-SDI 接收的数据移入 Master-SSPBUF. 在单次数据传输完成之后, 用户程序可以通过从 Master 设备的 Rx-Data 寄存器读取 Master 设备数据交换得到的数据。



![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/change.jpeg)





![img](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/forward.jpeg)





*******************************************************************************************************************************************************************************************************************************************************************************************************

## 一、SCCB简介

SCCB(Serial Camera Control Bus)是OmniVision公司公布的串行相机总线协议。OV开头的相机模块例如OV7670都使用SCCB协议。鉴于它与I2C协议类似，为了方便，本文将其SIO_C线称为SCL，SIO_D线称为SDA。主要讲解两线SCCB协议的内容与程序实现。

## 二、电路连接图

对于两线SCCB，只需连接SIO_C和SIO_D即可。
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwOTUzMw==,size_16,color_FFFFFF,t_70.png)

## 三、协议的内容与程序实现

②两线SCCB总线协议分析：
<1>传输开始标志：每次传输（无论是读数据还是写数据），都要由主机操作总线，按时序图向SDA和SCL输出规定电平，这样从机在接收到相应电平时会知道数据的传输将要开始。传输开始的标志为：在SCL保持高电平期间，SDA完成高电平到低电平的转变，随后SCL恢复低电平。
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511143917547.png)

```c
void SCCB_Start(void)
{
    SCCB_SDA=1;       
    SCCB_SCL=1;	    
    delay_us(50);  
    SCCB_SDA=0;
    delay_us(50);	 //并不是必须为50us，不要太短即可
    SCCB_SCL=0;	    
}
123456789
```

<2>传输结束标志：
通知从机一次传输过程结束。标志：在SCL为高电平期间，SDA由低电平向高电平的转变
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511144159388.png)

```c
void SCCB_Stop(void)
{
    SCCB_SDA=0;
    delay_us(50);	 
    SCCB_SCL=1;	
    delay_us(50); 
    SCCB_SDA=1;	
    delay_us(50);
} 
123456789
```

<3>传输相（Transmission Phases）：
传输相是每次数据传输的一个基本单元。它由九个bit组成，其中高bit在前。第一位到第八位为bit7-bit0，**<u>第九位为Don’t care bit或NA bit。Don’t care bit</u>**及NA bit的具体含义将在下面介绍具体的相时介绍。而第九位究竟是Don’t care bit还是NA bit是由传输相的内容决定的，不同的相有不同的规定，也将在下面介绍具体的每一个相时进行说明。
![传输相示意图](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511144334429.png)
<4>写操作：
每向从机写一个字节数据称为一次写操作，但要向从机写入我们想要的一个字节数据前，还要告诉从机ID号是多少，将要写入数据的寄存器编号（Sub-Address）是多少，因此写操作的一个过程由三个相（Phase）组成。
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511144428653.png)
相1：向从机发送从机的ID号，SCCB协议支持一个主机和多个从机，因此这一个相是为了区分不同的从机，但如果我们只连接了一个从机时，也必须执行这样一个过程。实际上ID Address有8bit，其中bit7-bit1为从机的ID号，大小为0-127，一共能区分128个从机。OV7670的ID号为0x42。而bit0是用来区分该相所在的cycle是向从机写数据还是读数据，bit0=0代表写数据，bit0=1代表读数据，由于我们要向从机写数据，因此bit0应为0。而相1中紧跟在ID Address这8位数据后的第九位是一个Don’t care bit（图中打X的位）。对于OV7670来说，从机在接收到主机送来的8bit数据后，将在SCL=1的期间，在SDA引脚输出低电平。在这期间，主机就可以读取SDA上的电平并进行判断，如果读取到低电平，表示从机已经顺利接收到了相1中的前8bit数据。说明数据传输成功，否则说明传输失败。

相2：向从机发送将要写入数据的寄存器的编号，寄存器的编号在OV传感器的数据手册上都能找到。寄存器的编号是一个8bit的数据。同样地，相2的第9bit也是一个Don’t care bit（图中打X的位），对该位的说明与相1相同

相3：前面两个相指定了数据传输的从机ID以及要写入数据的寄存器的编号，这时候在第三个相就可以向前面指定的寄存器写入数据了。bit7-bit0是我们希望写入寄存器的数据。而第9bit也是一个Don’t care bit（图中打X的位），对该位的说明与相1相同。

尽管每个相写入的数据不同，但其时序都是相同的，并且第九bit都是Don’t care bit。因此可以把每个相的写入编写成一个函数，如下：

```c
u8 SCCB_WR_Byte(u8 dat)//写1个相
{
	u8 j,res;	 
	for(j=0;j<8;j++) //循环发送bit7-bit0
	{
		if(dat&0x80)SCCB_SDA=1;	
		else SCCB_SDA=0;
		dat<<=1;
		delay_us(50);
		SCCB_SCL=1;	
		delay_us(50);
		SCCB_SCL=0;		   
	}			 
	SCCB_SDA_IN();		//设置SDA为输入
	delay_us(50);
	SCCB_SCL=1;			//将SCL置1，此时如果数据已被从机接收，从机将把SDA置0
	delay_us(50);
	if(SCCB_READ_SDA)res=1;  //SDA置1，说明从机没有成功接收数据
	else res=0;         //发送成功
	SCCB_SCL=0;		 
	SCCB_SDA_OUT();		//设置SDA为输出，为下一个相的输出作准备  
	return res;  
}	
1234567891011121314151617181920212223
```

根据上面写操作的说明，每向从机的某一个寄存器写一个字节的数据都要完成3个相的数据传输，将这3个相的数据写入过程编写成一个写寄存器函数。

```c
u8 SCCB_WR_Reg(u8 reg,u8 data)
{
	u8 res=0;
	SCCB_Start(); 					//启动传输的标志
	if(SCCB_WR_Byte(SCCB_ID))res=1;	//写入OV7670传感器ID	  
	delay_us(100);
  	if(SCCB_WR_Byte(reg))res=1;		//写寄存器地址
	delay_us(100);
  	if(SCCB_WR_Byte(data))res=1; 	//写要向寄存器写入的数据
  	SCCB_Stop();	                //结束传输的标志
  	return	res;
}		
123456789101112
```

<5>读操作：
根据SCCB协议，要从从机的寄存器读取一个字节的数据，需要完成两次数据传输过程：①包含两个相的写过程(2-Phase Write Transmission Cycle)②包含两个相的读过程(2-Phase Read Transmission Cycle)下面分别介绍：
①两相写传输过程：这个过程包含了两个相，均由主机发送给从机。第一个相指明从机的ID号。第二个相指明将要从从机的哪个寄存器读取数据。这些相各个bit的含义与上面写操作介绍过的含义是一致的。
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/2020051114473929.png)
②两相读传输过程：
上面一个传输过程告诉从机做好准备，主机将要读取数据了。而这一个传输过程则是真正的从从机读取数据。它也包含了两个相。
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511144807479.png)
相1：与上面相1的定义是一致的。但需要注意的是，此时是从从机读取数据，因此bit0应设置为1，可以用SCCB_ID|0x01（SCCB_ID是从机ID号的宏）来得到。
相2：从机向主机发送数据。因此应把主机连接SDA的IO口设置为输入模式。读取八个字节后，为了告诉从机已经成功收到数据，主机应向从机发送一个bit的应答信号（NA）。这个信号的时序定义如下：
![在这里插入图片描述](%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.assets/20200511144822836.png)
这个应答信号需要主机将SDA先拉高，然后在SDA高电平期间，将SCL由原来的低电平变为高电平再变为低电平。实现NAbit的代码如下

```c
void SCCB_No_Ack(void)
{
	delay_us(50);
	SCCB_SDA=1;	
	SCCB_SCL=1;	
	delay_us(50);
	SCCB_SCL=0;	
	delay_us(50);
	SCCB_SDA=0;	
	delay_us(50);
}
1234567891011
```

我们可以把相2中读取bit7-bit0的数据封装成一个函数

```c
u8 SCCB_RD_Byte(void)
{
	u8 temp=0,j;    
	SCCB_SDA_IN();		//设置主机SDA连接的IO口为输入
	for(j=8;j>0;j--) 	//循环读取bit7-bit0
	{		     	  
		delay_us(50);
		SCCB_SCL=1;
		temp=temp<<1;
		if(SCCB_READ_SDA)temp++;   //SCCB_READ_SDA是从IO口读到的数据
		delay_us(50);
		SCCB_SCL=0;
	}	
	SCCB_SDA_OUT();		//将主机连接SDA的IO口设置为输出  
	return temp;
} 
12345678910111213141516
```

有了以上的两个函数，再借助我们先前编写的写一相数据的u8 SCCB_WR_Byte(u8 dat)
函数，我们就可以编写一个完成整个读操作的函数

```c
u8 SCCB_RD_Reg(u8 reg)
{
	u8 val=0;
    //对应两相写操作
	SCCB_Start(); 				//启动传输
	SCCB_WR_Byte(SCCB_ID);  //相1		  
	delay_us(100);	 
  	SCCB_WR_Byte(reg);	   //相2  
	delay_us(100);	  
	SCCB_Stop();             //结束传输
	delay_us(100);	   
	//对应两相读操作
	SCCB_Start();            //启动传输
	SCCB_WR_Byte(SCCB_ID|0X01);	  //相1
	delay_us(100);
  	val=SCCB_RD_Byte();		 //相2
  	SCCB_No_Ack();            //读取完8bit数据后的应答
  	SCCB_Stop();              //结束传输
  	return val;
}
1234567891011121314151617181920
```

至此我们已经实现了SCCB的读寄存器和写寄存器操作的函数SCCB_RD_Reg和SCCB_WR_Reg。调用这两个函数就可以实现向OV传感器指定寄存器读写数据，从而完成传感器的初始化工作。

**sccb就是简化版的i2c总线，sccb不支持连续的，其余的方式都一样。**

