【1】linux内核中的并发和竞态的解决方法
	3.信号量（重点掌握）
		当一个进程获取到信号量之后，后一个进程
		也想获取到这个信号量，此时后一个进程就
		处于休眠的状态。
		
		特点：
			1.获取不到信号量的时候进程处于休眠的状态
			  此时不消耗cpu资源
			2.信号量工作在进程上下文
			3.在信号量保护的临界区中可以有延时，耗时
			  甚至休眠的操作。
		API:
			struct semaphore sem;
			//定义信号量
			void sema_init(struct semaphore *sem, int val)
			//信号量的初始化
			//信号量本身是一个同步的机制，只有当val被设置为1
			//的时候才有互斥的效果。如果把val设置为0它是一种
			//同步的机制。
			
			void down(struct semaphore *sem);
			//上锁，如果获取不到锁就会休眠
			int  down_trylock(struct semaphore *sem);
			//尝试获取锁，获取锁成功返回0，不成功返回1
			//如果获取不到锁是不会休眠的
			
			void up(struct semaphore *sem);
			//解锁
		
		
		
		
		
		
		
		
	4.互斥体（掌握）
	
	5.原子操作（掌握）
