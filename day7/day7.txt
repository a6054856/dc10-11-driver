【1】复习
	作业：
	2.编写ADC（73）的驱动，
	  要求加入中断，要求使用阻塞的IO模型读数据
	
	1.中断
	2.字符设备驱动
	3.IO模型-阻塞
	4.地址的映射
	5.readl和writel
	6.copy_from_user/copy_to_user
	7.自动创建设备节点
		
	控制的软中断号的获取方式？
	find -name irqs.h
	./arch/arm/mach-s5p6818/include/mach/irqs.h
	
	find -name s5p6818_irq.h
	./arch/arm/mach-s5p6818/include/mach/s5p6818_irq.h
	
	#define IRQ_PHY_ADC    (41 + 32)

【2】linux内核中断消抖
	在arm裸机开发中直接加延时即可。
	但在linux内核启动后，在中断的处理函数中是不允许
	有延时或者耗时操作的。使用内核定时器来完成消抖。
	
	
	1.分配对象
		struct timer_list {
			struct list_head entry; //定时器的链表
			unsigned long expires;  //定时的时间
			void (*function)(unsigned long data);//定时器的处理函数
			unsigned long data; //向定时器处理函数传递的参数
		};
		struct timer_list mytimer;
	2.对象的初始化
		1.当前时间获取：jiffies（时钟节拍数）
		（jiffies从内核启动开始一直运行的一个时间）
		
		2.加1走的时间：
			.config ===>CONFIG_HZ=1000

		mytimer.expires = jiffies + 10;
		mytimer.function = timer_function;
		mytimer.data = 0;
		init_timer(&mytimer);
	3.对象的注册
		add_timer(&mytimer); //注册并启动定时，只是启动一次
		
		再次启动定时器：
		int mod_timer(struct timer_list *timer, unsigned long expires)
	
	4.对象的注销
		int del_timer(struct timer_list *timer)
	
【3】gpio子系统
user	
-------------------------------------------------
kernel |设备驱动层：这是驱动工程师完成的代码
	   |
	   |-----------------------------------------
	   |核心层：内核工程师编写的代码 gpiolib.c
	   |-----------------------------------------
	   |厂商的驱动代码：厂商已经编写了操作硬件的函数
	   |接口了。
-------------------------------------------------
hardware  LED

	API:#include <linux/gpio.h>
		int gpio_request(unsigned gpio, const char *label)
		功能:申请gpio去使用
		参数：
			@gpio：要使用的gpio的编号
			@label:名字标号,NULL
		返回值：成功返回0 失败返回错误码
		
		
		int gpio_direction_input(unsigned gpio)
		功能：设置gpio的方向为输入
		参数：
			@gpio:gpio号
		返回值：成功返回0 失败返回错误码

		int gpio_direction_output(unsigned gpio, int value)
		功能：设置gpio的方向为输出
		参数：
			@gpio:gpio号
			@value：0表述输出低电平，1表示输出高电平
		返回值：成功返回0 失败返回错误码
		
		void gpio_set_value(unsigned gpio, int value)
		功能；设置gpio输出的高低电平
		参数：
			@gpio:gpio号
			@value：0表述输出低电平，1表示输出高电平
		返回值：无
		
		int gpio_get_value(unsigned gpio)
		功能：读取gpio的电平的值
		参数：
			@gpio:gpio号
		返回值：0读取到的是低电平，1读取到的是高电平
		
		void gpio_free(unsigned gpio)
		功能：释放gpio号
		参数：
			@gpio:gpio号
		返回值：无
	
	练习：
		1.内核定时器和gpio子系统的使用
		2.尝试使用内核定时器对中断消抖
	
----------------------------------------------------------
【1】中断底半部
	在中断处理函数不允许做延时，耗时，甚至休眠的操作，
	但是有时候又希望在中断到来的时候做这些事情，所有这
	就产生的矛盾，内核为了解决这种矛盾的现象就引入中断
	底半部的机制来解决来解决这个矛盾。例如在网卡中断到来
	的时候希望在中断处理函数中从网卡芯片中读取网络的数据
	这个读取数据的过程比较耗时，就可以把这个耗时的操作放入
	中中断底半部中完成。内核中推出的中断底半部的机制有软
	中断，tasklet，工作队列。
	
	软中断：软中断工作在中断上下文，软中断在使用的时候是有
		个数限制的（32个）要求驱动工程师尽可能的不要使用软
		中断。
	
	tasklet：tasklet工作在中断上下文，它是基于软中断实现的，
		没有个数限制。tasklet不能够脱离中断执行。可以在tasklet
		中做相对耗时的操作，但是不要做长延时或者休眠的操作。
		
		struct tasklet_struct
		{
			struct tasklet_struct *next;
			//内核链表
			unsigned long state;
			//是否调用底半部执行的一个状态
			atomic_t count;
			//代表被调用执行的次数
			void (*func)(unsigned long);
			//中断的底半部处理函数
			unsigned long data;
			//向底半部处理函数传递的参数
		};
		
		//1.分配tasklet的结构体对象
		struct tasklet_struct tasklet;
		//2.初始化
		void tasklet_init(struct tasklet_struct *tasklet,
                     void (*func)(unsigned long),
                     unsigned long data)
		//3.调用执行
		void tasklet_schedule(struct tasklet_struct *tasklet);
		
		
	工作队列：工作队列工作在进程上下文，工作队列也是没有个数
		限制的，工作队列可以完全脱离中断执行。所以在工作队列中
		可以做延时耗时甚至休眠的操作。
	
		struct work_struct {
			atomic_long_t data; 
			//这是工作队列中的原子变量
			struct list_head entry;
			//内核的链表
			work_func_t func;
			//工作队列的处理函数
		};
		
		//1.分配对象
		struct work_struct work;
		
		//2.初始化对象
		void  mywork(struct work_struct *data)
		{
			
		}
		INIT_WORK(&work, mywork);
		//3.调用执行
		int schedule_work(struct work_struct *work)
		
	
	
	
	
	
	
	
	
	
	